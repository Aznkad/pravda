Formula
  =
    "exists" _ x:VariableSymbol _ phi: Formula {
    	return {type: "exists", var: x, arg: phi};
    }

    /
    
    "forall" _ x:VariableSymbol _ phi: Formula {
    	return {type: "forall", var: x, arg: phi};
    }
 
    /
 
  
    phi: Formula2 "->" psi: Formula {
    	return {type: "->", args: [phi, psi]};
    }
    
    /
    
    phi:Formula2 tail:(_ ("or") _ Formula)* {
      let args = [phi];
      tail.forEach(function(element) {args.push(element[3]); });
      if(args.length == 1)
          return args[0]
      else
          return {type: "or", args: args};
    }
    
    
    
Formula2
   =
   phi:Factor tail:(_ ("and") _ Formula)* {
      let args = [phi];
      tail.forEach(function(element) {args.push(element[3]); });
      if(args.length == 1)
          return args[0]
      else
          return {type: "and", args: args};
    }
    

Factor
  = "(" _ phi:Formula _ ")" { return phi; }
     
     /
     
    ("not") _ phi:Factor {
    	return  {type: "not", arg: phi};
    } 
    /
    AtomicFormula



AtomicFormula = p:PredicateSymbol "("  args: TermList ")" {
	return {type: "atomic", pred:p, args: args};
}



TermList
 = term:Term tail:( _ (",") _ Term)* {
      let args = [term];
      tail.forEach(function(element) {args.push(element[3][0]); });
      return args;
    }
    
    



Term 
 = VariableSymbol /
   f:FunctionSymbol "(" args: TermList ")" {
   	return {type: "term", func:f, args: args};
   }
 
 
VariableSymbol
 = "x" / "y" / "z" { return text();}
 
FunctionSymbol
 = "f" / "g" / "h" { return text();}
 
PredicateSymbol
  = ("P" / "Q" / "R") {return text(); }

 
_ "whitespace"
  = [ \t\n\r]*
